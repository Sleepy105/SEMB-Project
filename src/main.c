#include <Arduino.h>
#include <avr/interrupt.h>
#include <avr/io.h>
#include <inttypes.h>
#include <stdlib.h>
#include "AVR_CS.h"

enum status {RUNNING, WAITING, READY};

#define Hz_10 6250  // compare match register 16MHz/256/10Hz
#define Hz_2  31250 // compare match register 16MHz/256/2Hz
#define Hz_2k 31    // compare match register 16MHz/256/2kHz

#define STACK_SIZE_DEFAULT 100

#define STATUS_LED  5
#define TICK_LED    6
#define CS_LED      7
#define CNT_MAX     20
#define MAX_TASKS   14


typedef struct {
    volatile uint8_t* stack_ptr;    // Pointer to the address of the task's 'private' stack in memory
    uint8_t stack[STACK_SIZE_DEFAULT];
    void (*function_pointer)(void); // Pointer to task function.
    uint8_t _cnt_to_activation;     // Counts to zero. Activate function on zero.
    uint8_t priority;               // priority for fixed-priority scheduling
    uint8_t status;                 // status for scheduling.
    float   frequency;
} Task_cenas;


Task_cenas* tasks[MAX_TASKS] = {0};
uint8_t task_count = 0;
uint8_t cnt = CNT_MAX;
int task = 0;

#define self *(tasks[task])
#define yield() vPortYieldFromTick();
#define suspend() self.status = WAITING; suspend(); continue;

void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vTaskIncrementTick( void );
void vTaskSwitchContext( void );
uint8_t *pxPortInitialiseStack( uint8_t* pxTopOfStack, void (*pxCode)(), void *pvParameters );

void hardwareInit(int comp){
    noInterrupts();  // disable all interrupts
    
    pinMode(PD2, OUTPUT);
    pinMode(PD3, OUTPUT);
    pinMode(PD4, OUTPUT);
    pinMode(PD5, OUTPUT);
    pinMode(PD6, OUTPUT);
    pinMode(PD7, OUTPUT);

    TCCR1A = 0;
    TCCR1B = 0;
    TCNT1 = 0;
    
    OCR1A = comp;
    TCCR1B |= (1 << WGM12);     // CTC mode
    TCCR1B |= (1 << CS12);      // 256 prescaler
    TIMSK1 |= (1 << OCIE1A);    // enable timer compare interrupt

    interrupts();  // enable all interrupts
}

#define TASK(name, pr, fr, code) \
 void name##_f(void); \
 Task_cenas name = { \
    .function_pointer = name##_f , \
    .stack_ptr = 0, \
    ._cnt_to_activation = 0, \
    .priority = pr, \
    .status = READY, \
    .frequency = fr \
 }; \
 void name##_f(void) { \
    while (true) { \
        code \
    } \
    return; \
 }

TASK(idle, 255, { // lowest priority task will run when no other task can run. This task is always ready.
    for(uint32_t i = 500000; i > 0; i--) {
        asm("nop");
    }
    PORTD ^= _BV(STATUS_LED);    // Pisca-pisca no ma no ma ei
});

TASK(t1, 1, {
    for(uint32_t i = 500000; i > 0; i--) {
        asm("nop");
    }
    PORTD ^= _BV(2);    // Toggle

    suspend();
});

TASK(t2, 4, {
    for(uint32_t i = 500000; i > 0; i--) {
        asm("nop");
    }
    PORTD ^= _BV(3);    // Toggle
    
    suspend();
});

TASK(t3, 10, {
    for(uint32_t i = 500000; i > 0; i--) {
        asm("nop");
    }
    PORTD ^= _BV(4);    // Toggle
    
    suspend();
});



uint8_t addTask(Task_cenas* task) {
    task->stack_ptr = pxPortInitialiseStack(task->stack+STACK_SIZE_DEFAULT, task->function_pointer, 0);
    tasks[task_count] = task;
    task_count++;
    return task_count - 1;
}

uint16_t test = 0;
volatile void* volatile pxCurrentTCB = &test;

uint8_t *pxPortInitialiseStack( uint8_t* pxTopOfStack, void (*pxCode)(), void *pvParameters ) {
    uint16_t usAddress;
    /* Simulate how the stack would look after a call to vPortYield() generated by
    the compiler. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    usAddress = ( uint16_t ) pxCode;
    *pxTopOfStack = ( uint8_t ) ( usAddress & ( uint16_t ) 0x00ff );
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( uint8_t ) ( usAddress & ( uint16_t ) 0x00ff );
    pxTopOfStack--;

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( uint8_t ) 0x00;    /* R0 */
    pxTopOfStack--;
    *pxTopOfStack = ( (uint8_t) 0x80 );
    pxTopOfStack--;

    /* Now the remaining registers. The compiler expects R1 to be 0. */
    *pxTopOfStack = ( uint8_t ) 0x00;    /* R1 */

    /* Leave R2 - R23 untouched */
    pxTopOfStack -= 23;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( uint8_t ) ( usAddress & ( uint16_t ) 0x00ff );
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( uint8_t ) ( usAddress & ( uint16_t ) 0x00ff );

    /* Leave register R26 - R31 untouched */
    pxTopOfStack -= 7;

    return pxTopOfStack;
}

void vPortYieldFromTick( void ) {
    // This is a naked function so the context
    // must be saved manually. 
    portSAVE_CONTEXT();

    PORTD ^= _BV(TICK_LED);

    // Increment the tick count and check to see
    // if the new tick value has caused a delay
    // period to expire. This function call can
    // cause a task to become ready to run.
    vTaskIncrementTick();
    
    // See if a context switch is required.
    // Switch to the context of a task made ready
    // to run by vTaskIncrementTick() if it has a
    // priority higher than the interrupted task.
    vTaskSwitchContext();
    
    // Restore the context. If a context switch
    // has occurred this will restore the context of
    // the task being resumed.
    portRESTORE_CONTEXT();
    
    // Return from this naked function.
    asm volatile ( "ret" );
}

void vTaskIncrementTick() {
    // TODO
    if (cnt) {
        cnt--;
    } else {
        cnt = CNT_MAX;
    }
    
    return;
}

void vTaskSwitchContext() {

    if (cnt) {
        return;
    }

    if(tasks[task]->status == RUNNING)
        tasks[task]->status = READY;

    PORTD ^= _BV(CS_LED); // toggle Context Switch LED

    // find the highest priority task which is ready (i.e., task->priority is lowest)

    uint8_t run_next_id = 0;
    uint8_t run_next_pr = 255;
    for(uint8_t i = 0; i < task_count; i++){
        if(tasks[i] && tasks[i]->priority <= run_next_pr && tasks[i]->status == READY) {
            run_next_id = i;
            run_next_pr = tasks[i]->priority;
        }
    }

    task = run_next_id;
    tasks[task]->status = RUNNING;
    pxCurrentTCB = &tasks[task]->stack_ptr;
    
    return;
}



ISR(TIMER1_COMPA_vect, ISR_NAKED) {
    /* Call the tick function. */
    vPortYieldFromTick();

    /* Return from the interrupt. If a context
    switch has occurred this will return to a
    different task. */
    asm volatile ( "reti" );
}

int main() {

    addTask(&idle); // This task must be the first one for its id to be 0.
    addTask(&t1);
    addTask(&t2);
    addTask(&t3);

    hardwareInit(Hz_10);
    while (true) {
        asm("nop"); // interrrupts will stop this.
    }
}
